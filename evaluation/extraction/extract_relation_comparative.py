import os
import glob
import random
import json
import openai
import time
import json
import numpy as np
import sys
sys.path.append("../")
from gpt_model import llm, set_key
import tqdm
import argparse

def main(args):
    set_key()
    
    path =args.caption_path
  
    with open(path, 'r') as f:
        generated_caps = json.load(f)
        
    messages = [
        {
            "role": "system", 
            "content": "You are a language assistant that helps to extract the ranking from given sentences." 
        },
    ]
    content = """
        Given an image with a caption that is generated by a vision language model. 
        Please act as a linguistic master and extract the rank of all the objects from large to small as mentioned in the captions.
        Your answer should be a dict of values which the keys represent the ranks starting from 1 and values are the No.1 largest object to smallest.
        If the caption does not mention the order of the object, you can by default view the order of objects appearance as from largest to smallest.
        If there are no objects mentioned in the caption, you can return an empty dict.
        For clarity, consider these examples:
        
        ### Example 1:
        - Caption: From largest to smallest, the objects in the image are a large brown teddy bear, a green trash can, and two black trash bags. The teddy bear is the largest object, followed by the green trash can, and then the two black trash bags
        - rank: {{"1": teddy bear, "2": green trash can, "3": black trash bags}}
        
        ### Example 2:
        - Caption: In the image, there are two young children, a boy and a girl, standing next to each other in a kitchen. The boy is wearing a chef's hat, while the girl is holding a piece of broccoli. They appear to be preparing food together, possibly for a meal or snack.There are several objects in the kitchen, including a bowl, a knife, a book, a cup, and a bottle. These items suggest that the kitchen is well-equipped and suitable for cooking and preparing meals
        - rank: {{"1": boy, "2": girl, "3": broccoli, "4":bowl, "5": knife, "6": book, "7": cup, "8": bottle}}
        
        ### Example 3:
        - Caption: 1. Tennis court (large) 2. Man holding a tennis racket (medium) 3. Woman wearing a red hat (medium) 4. Woman wearing a blue dress (medium) 5. Chairs (small) 6. Tennis ball (small)
        - rank: {{"1": Tennis court, "2": Man holding a tennis racket, "3": Woman wearing a red hat, "4": Woman wearing a blue dress, "5": Chairs, "6": Tennis ball}}
        
        ### Example 4:
        - Caption: box
        -rank : {{"1": box}}
        
        With these examples in mind, please help me extract the relations based on the information in the caption.
        Here is the caption:
        {}
    """
    
    outpath = args.output_file_path
    
    for image_id, cap in tqdm.tqdm(list(generated_caps.items())):
        cap_to_gpt = cap['generated_caption']
        # remove repeated captions
        each_cap = cap_to_gpt.split('.')
        if len(each_cap)>=4 and each_cap[1] == each_cap[3]:
            cap_to_gpt = each_cap[0] + '.' + each_cap[1] 
        #handle I'm sorry and Sorry from gpt4v who refuse to answer the question 
        if (len(cap_to_gpt) >= 5 and cap_to_gpt[:5] == "Sorry" ) or (len(cap_to_gpt) >= 9 and cap_to_gpt[:9] == "I'm sorry"):
            cap_to_gpt = ""
            llm_output = ""
        else: 
            input = content.format(cap_to_gpt)      
            prompt = messages + [{"role": "user", "content": input}]
            llm_output = llm(prompt)
        current_output = {
            "image_id": image_id,
            "response": llm_output,
            "generated_caption": cap_to_gpt
        }
        with open(outpath, "a") as f:
            f.write(json.dumps(current_output)+"\n")

        print(llm_output)
        
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="objects extracting")
    parser.add_argument("-ip", "--caption_path", type=str, required=True)
    parser.add_argument("-op", "--output_file_path", type=str, required=True)
    args = parser.parse_args()
    main(args)

